Process for creating new scenes:
  1. In IDE, create new javafx file
  2. The ide will then highlight a controller variable and ask if it should make the controller
  3. rename/refactor the controller name (it will probably not say "Controller"
  4. Open the fxml file in scenebuilder and profit!

In order to control size of scene in scenebuilder, do *not* specify the size in the controller file.

To move Main:
- Don't move Main!
- Commit to version control
- change the name of the package main is in
- make a new package
- move those other files to the new package
- if there is a problem, revert to that previous commit.  Try again.
Moving main doesn't seem to work, so that is my workaround.

To use a button to switch to a new scene:
# The short version is just copy one of my other methods, altering the param to "getResource" to match the name of the fxml file
- Make sure that the widget (button) has both an fxid and a field in the controller
- Write the method in the controller, (I've been using a MouseEvent as a parameter)
-- This method throws an IOException
-- instantiates a Parent with the name of the fxml file that will be opened (the fxml file of the new scene)
-- Instantiates a Scene taking the Parent as a parameter
-- ackk, I don't fully understand some of the commands necessary, so just copy them.  LOL.
--- they involve Stage, Node, either one or two casts with some weird nesting.  ??

To add a project to Github: (apparently intellij can't just make this happen even if given github creds)
- create the new project on github via your web browser
-- I think that you should avoid clicking the "add readme" button b/c that can cause initial push conflicts.  Could be wrong.
- git remote add origin <PASTE GITHUB URL>    (At the command prompt within the relevant dir)
-- I had to use the -f option (possibly d/t the presence of the readme mentioned above, note that this is dangerous
   if  the project is already established [you could overwrite an existing project])

Intellij Shortcuts:
- ctrl+shft+Enter  Finishes line, meaning it will add all the right closing parentheses and semicolons.


**********this was removed from Main after a video with Malcom Wabara.  Important info here!  ***********************

        DBQuery.setStatement(conn);  //create statement Object
        Statement statement = DBQuery.getStatement();

        // raw sql insert statement
        //String insertStatement = "INSERT INTO country(country, createDate, createdBy, lastUpdateBy) Values('US', '2020-02-22 00:00:00', 'admin', 'admin')";
        /*
        // Variable Insert
        String countryName = "Canada";
        String createDate = "2020-02-22 00:00:00";
        String createdBy = "admin";
        String lastUpdateBy = "admin";

        String insertStatement = "INSERT INTO country(country, createDate, createdBy, lastUpdateBy)" +
                "Values(" +
                "'" + countryName + "'," +
                "'" + createDate + "'," +
                "'" + createdBy + "'," +
                "'" + lastUpdateBy + "'" +
                ")";

         */

        // Update statement
        //String updateStatement = "UPDATE country SET country = 'Japan' WHERE country = 'Canada'";

        // Delete statement
        String deleteStatement = "DELETE FROM country WHERE country = 'Japan'";

        // Execute SQL statement
        statement.execute(deleteStatement);  //this param changed from insertStatement to updateStatement

        //confirm rows effected
        if(statement.getUpdateCount() > 0)
            System.out.println( statement.getUpdateCount()+ " rows(s) affected");
        else
            System.out.println("No Changes!");




**********main() after jdbcIII.  Notice that a lot of stuff has been commented out, because MW had us disable
code as we made progress.  I think that JDBCIII might not be that helpful in the project d/t the fact that it uses the
"bad old way" of doing things, namely "Statement" as opposed to "PreparedStatement".  Not sure though.

    public static void main(String[] args) throws Exception {
        Connection conn = DBConnection.startConnection();  //connect to database

        DBQuery.setStatement(conn);  //create statement Object
        Statement statement = DBQuery.getStatement();  //get statement reference // I think that Statements are bad vs "PreparedStatements"

        String country, createDate, createdBy, lastUpdateBy;
        Scanner keyboard = new Scanner(System.in);
        System.out.println("Enter a country: ");

        country = keyboard.nextLine();
        createDate = "2020-03-14 00:00:00";
        createdBy = "admin";
        lastUpdateBy = "admin";

        if(country.contains("'")) {
            country = country.replace("'", "\\'");
        }

        //String selectStatement = "SELECT * FROM country WHERE " + country;  // select statement //from first half of video
        String selectStatement = "INSERT INTO country(country, createDate, createdBy, lastUpdateBy)" +
                "VALUES(" +
                "'" + country + "'," +
                "'" + createDate + "'," +
                "'" + createdBy + "'," +
                "'" + createdBy + "'" +
                ")";


        try {
            statement.execute(selectStatement);  // execute statement

            if(statement.getUpdateCount() > 0)
                System.out.println(statement.getUpdateCount() + " row(s) affected!");
            else
                System.out.println("No change!");

            //ResultSet rs = statement.getResultSet();  //get resultSet

//            // Forward scroll ResultSet
//            while (rs.next()) {
//                int countryId = rs.getInt("countryId");
//                String countryName = rs.getString("country");
//                LocalDate date = rs.getDate("createDate").toLocalDate();  //"Date" is old and possibly deprecated.  Using LocalDate instead.
//                LocalTime time = rs.getTime("createDate").toLocalTime();
//                String createdBy = rs.getString("createdBy");
//                LocalDateTime lastUpdate = rs.getTimestamp("lastUpdate").toLocalDateTime();
//                // Malcom says "you don't have to retrieve every column in a result set."  So omitting one column here.
//
//                //display record
//                System.out.println(countryId +
//                        " | " + countryName +
//                        " | " + date +
//                        " | " + time +
//                        " | " + createdBy +
//                        " | " + lastUpdate);
//            }
        }
        catch(Exception e) {
            System.out.println(e.getMessage());

        }
        launch(args);

        DBConnection.closeConnection();
    }



************** Thoughts on where "Connections" should be

In the instructor's examples, they open the connection in main before they start the UI, and close it after the UI closes.  The
problem that I am anticipating is that for queries, deletes, etc, you need a reference to the Connection.  So if my
Connection reference were in main, then it would have to be static, and that connection would have to remain open for
the life of the program (and I think that is bad practice).  According to:
https://stackoverflow.com/questions/9428573/is-it-safe-to-use-a-static-java-sql-connection-instance-in-a-multithreaded-syste
you want that Connection to be open for as short a period of time as possible.  This may not be necessary for this app, b/c
I won't have hundreds of users, but I dunno.  I think that the correct course of action is to open a connection when a
"scene" is started so that it can be used to populate the data, then closed.  Then when a "save" button is pressed, the
connection will reopen in order to save the changes then immediately close.  Of course a "save" button will open a new
Scene, so immediately after the "save" function finishes it's job and closes, a new connection will be momentarily opened
so that it can populate the new scene.  This seems excessive, but maybe that's the right way to do it?

^^ Can confirm!  At the very end of MW's video, a student asks this very question, and MW answers.  (Think when a "save button is pressed)"  ^^

************* An attempt to understand MW's series on jdbc, specifically PreparedStatements:

1.  Connect to DB.  In my app, this involves using the startConnection() method, but that ultimately uses the getConnection()
method from DriverManager.  I've been using "conn" as a reference.

    Connection conn = DBConnection.startConnection();

2.  Make the string to be altered (by the ps.setString() method).  It will use the '?' symbol for variable placeholders.

String delStatement = "DELETE FROM country WHERE country = ?";

3. In my app, I use DBQuery.setPreparedStatement(), which in turn uses conn.prepareStatement() (conn is a reference to
an instance of Connection in all these steps)  This creates a PreparedStatement object. Note that this requires some
exception control, the IDE will suggest using a throws clause, but it is probably better to use a try/catch block.

     DBQuery.setPreparedStatement(conn, updateStatement);

4.  In my app, I use DBQuery.getPreparedStatement() which returns the PreparedStatement object (which is a static field
in my DBQuery class) and assigns it to a reference.  Following MW's example, I use "ps" as the reference.

     PreparedStatement ps = DBQuery.getPreparedStatement();

5. Set some strings to replace those question marks

        ps.setString(1, newCountryName);    //note that these are 1 indexed, not 0 indexed.
        ps.setString(2, createdBy);

6. Use the execute method from PreparedStatement

        ps.execute();


7. OPTIONAL:  Check if any lines were effected.  If so, list how many.

        if (ps.getUpdateCount() > 0) {
            System.out.println(ps.getUpdateCount() + " rows affected");
        } else {
            System.out.println("No change!");
        }

8. Close Connection.  Note that for some reason, if you're throwing the SqlException, this will cause Intellij to change
that to a more general Exception. Not I think that if I were using a try/catch statement, I'd have to have two catch
clauses, one for the SQLException, one for  Exception.  Maybe Exception can handle all of it though.  Might be worth
a shot.
        DBConnection.closeConnection();

**********
I'm starting to realize that I have DB IO code all over the place, and I don't know how I feel about it.  I think that
this is what DAO is all about.  Maybe it *would* be nice to have my IO stuff in dedicated files.